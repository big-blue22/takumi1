# リトライ処理実装レポート

## 実装概要

`gemini-service.js` に 503 Service Unavailable エラーに対する堅牢なリトライ処理を実装しました。

---

## 実装要件

### ✅ 完了した要件

1. **[必須] 503エラー発生時のリトライ**
   - ✅ 503 Service Unavailable エラーが発生した場合、自動的にリクエストを再試行
   - ✅ 指数バックオフ（Exponential Backoff）アルゴリズムを使用
   - ✅ 最大リトライ回数は3回に設定
   - ✅ 3回リトライしても成功しない場合は、最終的なエラーをスロー
   - ✅ 503以外のエラー（4xx系）は、リトライせずに即座にエラーをスロー

2. **[必須] コードの生成**
   - ✅ リトライ処理を実装した `gemini-service.js` の完全な実装コードを生成
   - ✅ npmパッケージの依存: **なし**（ブラウザベースのアプリケーションのため）

---

## 技術詳細

### 指数バックオフアルゴリズム

**計算式:**
```javascript
waitSeconds = retryDelay * Math.pow(2, retryCount) / 1000
```

**リトライ間隔:**
- **1回目のリトライ**: 1秒後
- **2回目のリトライ**: 2秒後
- **3回目のリトライ**: 4秒後

| リトライ回数 | retryCount | 計算 | 待機時間 |
|------------|-----------|------|---------|
| 1回目 | 0 | 1000 × 2⁰ ÷ 1000 | 1秒 |
| 2回目 | 1 | 1000 × 2¹ ÷ 1000 | 2秒 |
| 3回目 | 2 | 1000 × 2² ÷ 1000 | 4秒 |

---

## 実装コード

### 変更箇所1: 設定の更新（13-14行目）

```javascript
this.retryDelay = 1000; // 初期リトライ間隔（指数バックオフの基準）
this.maxRetries = 3;    // 503エラー用の最大リトライ回数
```

**変更内容:**
- `maxRetries` を 2 から 3 に変更
- コメントを追加してコードの意図を明確化

### 変更箇所2: 503エラー処理の簡素化（378-412行目）

```javascript
// 503エラーの場合、指数バックオフでリトライ
if (response.status === 503) {
    const errorData = await response.json().catch(() => null);
    console.error(`🔍 503エラーの詳細:`, {
        errorData: errorData,
        responseHeaders: Object.fromEntries(response.headers.entries()),
        url: maskUrl(url),
        requestBodySample: JSON.stringify(requestBody).substring(0, 200) + '...'
    });
    
    // 最大リトライ回数をチェック
    if (retryCount < this.maxRetries) {
        // 指数バックオフ: 1秒 -> 2秒 -> 4秒
        const waitSeconds = this.retryDelay * Math.pow(2, retryCount) / 1000;
        const waitMs = waitSeconds * 1000;
        
        console.log(`⏳ 503エラー: ${retryCount + 1}回目のリトライを${waitSeconds}秒後に実行します...`);
        await this.delay(waitMs);
        return await this.makeAPIRequest(url, requestBody, retryCount + 1);
    }
    
    // 最大リトライ回数に達した場合、エラーをスロー
    const detailMessage = errorData?.error?.message || 'Service Unavailable';
    if (detailMessage.includes('quota') || detailMessage.includes('exceeded')) {
        throw new Error(`APIクォータまたは制限に達しています。しばらく待ってから再試行してください。`);
    } else if (detailMessage.includes('billing') || detailMessage.includes('payment')) {
        throw new Error(`課金またはAPIキーの問題があります。Google Cloudコンソールで設定を確認してください。`);
    } else if (detailMessage.includes('region') || detailMessage.includes('location')) {
        throw new Error(`地域制限またはアクセス制限があります。お住まいの地域での利用可能性を確認してください。`);
    } else if (detailMessage.includes('overloaded') || detailMessage.includes('Overloaded')) {
        throw new Error(`Gemini AIサービスが一時的に過負荷状態です。数分後に再試行してください。`);
    } else {
        throw new Error(`Gemini AIサービスが一時的に利用できません (503)。しばらく待ってから再試行してください。`);
    }
}
```

**コード改善:**
- 複雑なフォールバックロジックを削除（61行削除）
- シンプルで焦点を絞ったリトライロジックを追加（12行追加）
- コードの可読性とメンテナンス性が向上

---

## 動作シナリオ

### シナリオ1: 503エラー → リトライ成功

```
⏱️  0秒: 初回リクエスト → 503エラー ❌
⏱️  1秒: 1秒待機後、Retry 1 → 503エラー ❌
⏱️  3秒: 2秒待機後、Retry 2 → 200 OK ✅

✅ 結果: リクエスト成功（合計約3秒で完了）
```

### シナリオ2: 503エラー → 全てのリトライ失敗

```
⏱️  0秒: 初回リクエスト → 503エラー ❌
⏱️  1秒: 1秒待機後、Retry 1 → 503エラー ❌
⏱️  3秒: 2秒待機後、Retry 2 → 503エラー ❌
⏱️  7秒: 4秒待機後、Retry 3 → 503エラー ❌
⏱️  7秒: 最終エラーをスロー

❌ 結果: 最終的にエラー（合計約7秒後に失敗）
エラーメッセージ: "Gemini AIサービスが一時的に過負荷状態です。数分後に再試行してください。"
```

### シナリオ3: 401エラー → 即座に失敗（リトライなし）

```
⏱️  0秒: 初回リクエスト → 401エラー ❌
⏱️  0秒: 即座にエラーをスロー（リトライなし）

❌ 結果: 認証エラーで即座に失敗
エラーメッセージ: "APIキーが無効か、権限がありません。APIキーを確認してください。"
```

---

## エラーハンドリング一覧

| ステータスコード | 説明 | リトライ動作 | 備考 |
|---------------|------|------------|-----|
| **503** | Service Unavailable | ✅ リトライする（最大3回） | 一時的なサーバー過負荷 |
| **401** | Unauthorized | ❌ 即座に失敗 | APIキー認証エラー |
| **403** | Forbidden | ❌ 即座に失敗 | アクセス権限エラー |
| **404** | Not Found | ❌ 即座に失敗 | エンドポイント不存在 |
| **429** | Too Many Requests | ❌ 即座に失敗 | レート制限超過 |
| **その他4xx** | Client Errors | ❌ 即座に失敗 | クライアント側エラー |

---

## 依存パッケージ

### 必要なnpmパッケージ: **なし**

この実装は、ネイティブJavaScript機能のみを使用しているため、外部パッケージは不要です。

**使用している機能:**
- `Math.pow()` - 指数計算
- `Promise` / `async/await` - 非同期処理
- ネイティブ `setTimeout` (`delay` メソッド経由) - 待機処理

---

## メリット

### 1. 信頼性の向上
一時的なサーバー過負荷を自動的に吸収し、アプリケーションの安定性を向上させます。

### 2. ユーザー体験の改善
一時的なエラーによるリクエスト失敗を削減し、ユーザーにストレスを与えません。

### 3. 適切な待機時間
指数バックオフにより、サーバーに過度な負荷をかけずに再試行します。

### 4. 高速な失敗
リトライ不可能なエラー（4xx系）は即座に失敗するため、無駄な待機時間がありません。

### 5. クリーンなコード
シンプルで理解しやすい実装により、メンテナンスが容易です。

---

## テスト結果

### ✅ 実施したテスト

1. **指数バックオフ計算の検証**
   - 1秒、2秒、4秒の待機時間が正しく計算されることを確認 ✅

2. **セキュリティスキャン（CodeQL）**
   - 脆弱性: 0件 ✅
   - 実装は安全です ✅

3. **コード品質**
   - コードが簡素化され、メンテナンスが容易に ✅
   - 61行削除、12行追加（正味49行の削減） ✅

### 📝 今後のテスト推奨事項

実際のAPIコールを使用した手動テストを推奨します：
1. 503エラーが発生した際のリトライ動作を確認
2. コンソールログでリトライ回数と待機時間を確認
3. 最終的なエラーメッセージが適切に表示されることを確認

---

## セキュリティ

### CodeQL分析結果

- **脆弱性の数**: 0件
- **新規依存パッケージ**: なし
- **セキュリティ問題**: なし

✅ **実装は安全です**

---

## まとめ

### 実装完了

503 Service Unavailableエラーに対する堅牢なリトライ処理の実装が完了しました。

### 主な成果

1. ✅ 指数バックオフアルゴリズムの実装（1秒 → 2秒 → 4秒）
2. ✅ 最大リトライ回数3回の設定
3. ✅ 4xx系エラーの即座の失敗
4. ✅ コードの簡素化（49行削減）
5. ✅ 包括的なドキュメント作成
6. ✅ セキュリティスキャン合格

### 今後の推奨事項

1. 実際の503エラー発生時の動作確認
2. ユーザーフィードバックの収集
3. 必要に応じてリトライ間隔や回数の調整

---

## サポート

実装に関する質問や問題がある場合は、以下のドキュメントを参照してください：

- `RETRY_IMPLEMENTATION.md` - 英語版の技術ドキュメント
- `gemini-service.js` - 実装コード

---

**実装完了日**: 2025年11月14日  
**実装者**: GitHub Copilot Coding Agent  
**ステータス**: ✅ 完了
